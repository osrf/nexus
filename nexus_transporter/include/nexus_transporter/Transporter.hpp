/*
 * Copyright (C) 2022 Johnson & Johnson
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
*/

#ifndef NEXUS_TRANSPORTER__TRANSPORTER_HPP
#define NEXUS_TRANSPORTER__TRANSPORTER_HPP

#include <rclcpp_lifecycle/lifecycle_node.hpp>

#include <nexus_transporter_msgs/msg/transporter_state.hpp>

#include <nexus_transporter/Itinerary.hpp>

//==============================================================================
namespace nexus_transporter {

/// Pure abstract base class that will be loaded as a plugin by TransporterNode
/// Users should implement this class for their transportation system.
class Transporter
{
public:

  // TODO(YV): Consider using type adaptation between TransportState.msg
  using TransporterState = nexus_transporter_msgs::msg::TransporterState;
  // A callback to execute to provide updates on the transportation
  using TransportFeedback = std::function<void(const TransporterState& state)>;
  /// A callback to execute once the transportation is completed
  using TransportCompleted = std::function<void(bool success)>;

  /// Configure the transporter including getting relevant information from
  /// ROS 2 parameters. (Eg. List of destinations)
  ///
  /// \param[in] node
  /// A weak pointer to an rclcpp_lifecycle node. It is important to not
  /// store the shared_ptr obtained from locking this node as it would lead
  /// to circular dependency issues.
  /// \return True if the configuration was successful.
  virtual bool configure(
    const rclcpp_lifecycle::LifecycleNode::WeakPtr& node) = 0;

  /// Return true if the transporter is configured and ready.
  virtual bool ready() const = 0;

  /// Receive an itinerary for a destination
  ///
  /// \param[in] job_id
  /// An id for this request.
  ///
  /// \param[in] destination
  /// The name of the destination
  ///
  /// \param[in] source
  /// The name of the source, empty if not needed (i.e. for a conveyor belt)
  /// \return A nullopt is returned if the destination is not valid.
  // TODO(YV): Consider creating a separate class for destination
  virtual std::optional<Itinerary> get_itinerary(
    const std::string& job_id,
    const std::string& destination,
    const std::string& source = "") = 0;

  /// Request the transporter to go to a destination. This call should be
  /// non-blocking.
  /// \param[in] itinerary
  ///   The itinerary previously generated by the transporter.
  ///   Note: The itinerary's validity should not have expired.
  ///
  /// \param[in] feedback_cb
  ///   A callback to execute to submit feedback on the transporter's progress
  ///
  /// \param[in] completed_cb
  ///   A callback to execute to when the transportation has failed or succeeded
  ///
  /// \param[in] signal_destination
  ///   The entity to send a signal to when the transporter is at the destination
  ///
  /// \param[in] signal_source
  ///   The entity to send a signal to when the transporter is at the source
  // TODO(luca) strings are easily swapped, create a class or wrap into itinerary
  virtual void transport_to_destination(
    const Itinerary& itinerary,
    TransportFeedback feedback_cb,
    TransportCompleted completed_cb,
    const std::string& signal_destination = "",
    const std::string& signal_source = "") = 0;

  /// Process a signal sent to this transporter, not all transporter might need
  /// this interface so it is not mandatory to implement it.
  /// \param[in] job_id
  ///   The id to send the signal to
  ///
  /// \param[in] signal
  ///   The signal to send
  ///
  /// \return An error message if the request failed, std::nullopt otherwise.
  virtual std::optional<std::string> process_signal(
    const std::string& /*job_id*/,
    const std::string& /*signal*/) { return "Transporter doesn't implement signals"; };

  /// Cancel the presently assigned task
  /// \param[in] itinerary
  ///   The itinerary of the task to cancel
  /// \return True if the cancellation was successful.
  virtual bool cancel(const Itinerary& itinerary) = 0;

  /// Virtual destructor
  virtual ~Transporter() = default;
};
} // namespace nexus_transporter

#endif // NEXUS_TRANSPORTER__TRANSPORTER_HPP

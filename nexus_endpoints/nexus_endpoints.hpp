/* This file is generated by redf */

#pragma once

#include <control_msgs/action/follow_joint_trajectory.hpp>
#include <control_msgs/action/gripper_command.hpp>
#include <nexus_alarm_msgs/msg/emergency_stop.hpp>
#include <nexus_calibration_msgs/srv/calibrate_extrinsics.hpp>
#include <nexus_detector_msgs/srv/detect.hpp>
#include <nexus_dispenser_msgs/srv/dispense_item.hpp>
#include <nexus_motion_planner_msgs/srv/get_motion_plan.hpp>
#include <nexus_orchestrator_msgs/action/execute_work_order.hpp>
#include <nexus_orchestrator_msgs/action/workcell_task.hpp>
#include <nexus_orchestrator_msgs/msg/work_order_state.hpp>
#include <nexus_orchestrator_msgs/msg/workcell_state.hpp>
#include <nexus_orchestrator_msgs/srv/get_work_order_state.hpp>
#include <nexus_orchestrator_msgs/srv/is_task_doable.hpp>
#include <nexus_orchestrator_msgs/srv/list_transporters.hpp>
#include <nexus_orchestrator_msgs/srv/list_workcells.hpp>
#include <nexus_orchestrator_msgs/srv/pause_system.hpp>
#include <nexus_orchestrator_msgs/srv/pause_workcell.hpp>
#include <nexus_orchestrator_msgs/srv/queue_workcell_task.hpp>
#include <nexus_orchestrator_msgs/srv/register_transporter.hpp>
#include <nexus_orchestrator_msgs/srv/register_workcell.hpp>
#include <nexus_orchestrator_msgs/srv/remove_pending_task.hpp>
#include <nexus_orchestrator_msgs/srv/signal_workcell.hpp>
#include <nexus_transporter_msgs/action/transport.hpp>
#include <nexus_transporter_msgs/srv/is_transporter_available.hpp>
#include <trajectory_msgs/msg/joint_trajectory.hpp>

#include <rclcpp/rclcpp.hpp>
#include <rclcpp_action/rclcpp_action.hpp>

#include <string>


namespace nexus::endpoints {

class ListWorkcellsService {
public:
  using ServiceType = nexus_orchestrator_msgs::srv::ListWorkcells;

  static inline std::string service_name() {
    const std::string name = "/list_workcells";
    return name;
  }

  template<typename NodePtrT, typename CallbackT>
  static rclcpp::Service<ListWorkcellsService::ServiceType>::SharedPtr create_service(NodePtrT node, CallbackT&& callback) {
    return node->template create_service<ListWorkcellsService::ServiceType>(ListWorkcellsService::service_name(), std::forward<CallbackT>(callback));
  }

  template<typename NodePtrT>
  static rclcpp::Client<ListWorkcellsService::ServiceType>::SharedPtr create_client(NodePtrT node) {
    return node->template create_client<ListWorkcellsService::ServiceType>(ListWorkcellsService::service_name());
  }
};

/**
 * Current state of a workcell
 */
class WorkcellStateTopic {
public:
  using MessageType = nexus_orchestrator_msgs::msg::WorkcellState;

  static inline std::string topic_name(const std::string& workcell_id) {
    const std::string topic = "/" + workcell_id + "/workcell_state";
    return topic;
  }

  static inline rclcpp::QoS qos(size_t history_depth = 10) {
    rclcpp::QoS qos{history_depth};
    qos.reliability(rclcpp::ReliabilityPolicy::Reliable);
    qos.durability(rclcpp::DurabilityPolicy::TransientLocal);
    qos.liveliness(rclcpp::LivelinessPolicy::SystemDefault);
    qos.avoid_ros_namespace_conventions(false);
    return qos;
  }

  template<typename NodePtrT>
  static rclcpp::Publisher<WorkcellStateTopic::MessageType>::SharedPtr create_publisher(NodePtrT node, const std::string& workcell_id, size_t history_depth = 10) {
    return node->template create_publisher<WorkcellStateTopic::MessageType>(WorkcellStateTopic::topic_name(workcell_id), WorkcellStateTopic::qos(history_depth));
  }

  template<typename NodePtrT, typename CallbackT>
  static rclcpp::Subscription<WorkcellStateTopic::MessageType>::SharedPtr create_subscription(NodePtrT node, const std::string& workcell_id, CallbackT&& callback, size_t history_depth = 10) {
    return node->template create_subscription<WorkcellStateTopic::MessageType>(WorkcellStateTopic::topic_name(workcell_id), WorkcellStateTopic::qos(history_depth), std::forward<CallbackT>(callback));
  }
};

class WorkOrderAction {
public:
  using ActionType = nexus_orchestrator_msgs::action::ExecuteWorkOrder;

  static inline std::string action_name() {
    const std::string name = "/system_orchestrator/execute_order";
    return name;
  }

  template<typename NodePtrT>
  static rclcpp_action::Server<WorkOrderAction::ActionType>::SharedPtr create_server(NodePtrT node, typename rclcpp_action::Server<WorkOrderAction::ActionType>::GoalCallback handle_goal, typename rclcpp_action::Server<WorkOrderAction::ActionType>::CancelCallback handle_cancel, typename rclcpp_action::Server<WorkOrderAction::ActionType>::AcceptedCallback handle_accepted) {
    return rclcpp_action::create_server<WorkOrderAction::ActionType>(node, WorkOrderAction::action_name(), handle_goal, handle_cancel, handle_accepted);
  }

  template<typename NodePtrT>
  static rclcpp_action::Client<WorkOrderAction::ActionType>::SharedPtr create_client(NodePtrT node) {
    return rclcpp_action::create_client<WorkOrderAction::ActionType>(node, WorkOrderAction::action_name());
  }
};

/**
 * States of work orders
 */
class WorkOrderStatesTopic {
public:
  using MessageType = nexus_orchestrator_msgs::msg::WorkOrderState;

  static inline std::string topic_name() {
    const std::string topic = "/work_order_states";
    return topic;
  }

  static inline rclcpp::QoS qos(size_t history_depth = 10) {
    return rclcpp::QoS{history_depth};
  }

  template<typename NodePtrT>
  static rclcpp::Publisher<WorkOrderStatesTopic::MessageType>::SharedPtr create_publisher(NodePtrT node, size_t history_depth = 10) {
    return node->template create_publisher<WorkOrderStatesTopic::MessageType>(WorkOrderStatesTopic::topic_name(), WorkOrderStatesTopic::qos(history_depth));
  }

  template<typename NodePtrT, typename CallbackT>
  static rclcpp::Subscription<WorkOrderStatesTopic::MessageType>::SharedPtr create_subscription(NodePtrT node, CallbackT&& callback, size_t history_depth = 10) {
    return node->template create_subscription<WorkOrderStatesTopic::MessageType>(WorkOrderStatesTopic::topic_name(), WorkOrderStatesTopic::qos(history_depth), std::forward<CallbackT>(callback));
  }
};

class GetWorkOrderStateService {
public:
  using ServiceType = nexus_orchestrator_msgs::srv::GetWorkOrderState;

  static inline std::string service_name() {
    const std::string name = "/get_work_order_state";
    return name;
  }

  template<typename NodePtrT, typename CallbackT>
  static rclcpp::Service<GetWorkOrderStateService::ServiceType>::SharedPtr create_service(NodePtrT node, CallbackT&& callback) {
    return node->template create_service<GetWorkOrderStateService::ServiceType>(GetWorkOrderStateService::service_name(), std::forward<CallbackT>(callback));
  }

  template<typename NodePtrT>
  static rclcpp::Client<GetWorkOrderStateService::ServiceType>::SharedPtr create_client(NodePtrT node) {
    return node->template create_client<GetWorkOrderStateService::ServiceType>(GetWorkOrderStateService::service_name());
  }
};

class IsTaskDoableService {
public:
  using ServiceType = nexus_orchestrator_msgs::srv::IsTaskDoable;

  static inline std::string service_name(const std::string& workcell_id) {
    const std::string name = "/" + workcell_id + "/is_task_doable";
    return name;
  }

  template<typename NodePtrT, typename CallbackT>
  static rclcpp::Service<IsTaskDoableService::ServiceType>::SharedPtr create_service(NodePtrT node, const std::string& workcell_id, CallbackT&& callback) {
    return node->template create_service<IsTaskDoableService::ServiceType>(IsTaskDoableService::service_name(workcell_id), std::forward<CallbackT>(callback));
  }

  template<typename NodePtrT>
  static rclcpp::Client<IsTaskDoableService::ServiceType>::SharedPtr create_client(NodePtrT node, const std::string& workcell_id) {
    return node->template create_client<IsTaskDoableService::ServiceType>(IsTaskDoableService::service_name(workcell_id));
  }
};

class WorkcellRequestAction {
public:
  using ActionType = nexus_orchestrator_msgs::action::WorkcellTask;

  static inline std::string action_name(const std::string& workcell_id) {
    const std::string name = workcell_id + "/request";
    return name;
  }

  template<typename NodePtrT>
  static rclcpp_action::Server<WorkcellRequestAction::ActionType>::SharedPtr create_server(NodePtrT node, const std::string& workcell_id, typename rclcpp_action::Server<WorkcellRequestAction::ActionType>::GoalCallback handle_goal, typename rclcpp_action::Server<WorkcellRequestAction::ActionType>::CancelCallback handle_cancel, typename rclcpp_action::Server<WorkcellRequestAction::ActionType>::AcceptedCallback handle_accepted) {
    return rclcpp_action::create_server<WorkcellRequestAction::ActionType>(node, WorkcellRequestAction::action_name(workcell_id), handle_goal, handle_cancel, handle_accepted);
  }

  template<typename NodePtrT>
  static rclcpp_action::Client<WorkcellRequestAction::ActionType>::SharedPtr create_client(NodePtrT node, const std::string& workcell_id) {
    return rclcpp_action::create_client<WorkcellRequestAction::ActionType>(node, WorkcellRequestAction::action_name(workcell_id));
  }
};

class QueueWorkcellTaskService {
public:
  using ServiceType = nexus_orchestrator_msgs::srv::QueueWorkcellTask;

  static inline std::string service_name(const std::string& workcell_id) {
    const std::string name = workcell_id + "/queue_task";
    return name;
  }

  template<typename NodePtrT, typename CallbackT>
  static rclcpp::Service<QueueWorkcellTaskService::ServiceType>::SharedPtr create_service(NodePtrT node, const std::string& workcell_id, CallbackT&& callback) {
    return node->template create_service<QueueWorkcellTaskService::ServiceType>(QueueWorkcellTaskService::service_name(workcell_id), std::forward<CallbackT>(callback));
  }

  template<typename NodePtrT>
  static rclcpp::Client<QueueWorkcellTaskService::ServiceType>::SharedPtr create_client(NodePtrT node, const std::string& workcell_id) {
    return node->template create_client<QueueWorkcellTaskService::ServiceType>(QueueWorkcellTaskService::service_name(workcell_id));
  }
};

class RemovePendingTaskService {
public:
  using ServiceType = nexus_orchestrator_msgs::srv::RemovePendingTask;

  static inline std::string service_name(const std::string& workcell_id) {
    const std::string name = workcell_id + "/remove_pending_task";
    return name;
  }

  template<typename NodePtrT, typename CallbackT>
  static rclcpp::Service<RemovePendingTaskService::ServiceType>::SharedPtr create_service(NodePtrT node, const std::string& workcell_id, CallbackT&& callback) {
    return node->template create_service<RemovePendingTaskService::ServiceType>(RemovePendingTaskService::service_name(workcell_id), std::forward<CallbackT>(callback));
  }

  template<typename NodePtrT>
  static rclcpp::Client<RemovePendingTaskService::ServiceType>::SharedPtr create_client(NodePtrT node, const std::string& workcell_id) {
    return node->template create_client<RemovePendingTaskService::ServiceType>(RemovePendingTaskService::service_name(workcell_id));
  }
};

class RegisterWorkcellService {
public:
  using ServiceType = nexus_orchestrator_msgs::srv::RegisterWorkcell;

  static inline std::string service_name() {
    const std::string name = "/register_workcell";
    return name;
  }

  template<typename NodePtrT, typename CallbackT>
  static rclcpp::Service<RegisterWorkcellService::ServiceType>::SharedPtr create_service(NodePtrT node, CallbackT&& callback) {
    return node->template create_service<RegisterWorkcellService::ServiceType>(RegisterWorkcellService::service_name(), std::forward<CallbackT>(callback));
  }

  template<typename NodePtrT>
  static rclcpp::Client<RegisterWorkcellService::ServiceType>::SharedPtr create_client(NodePtrT node) {
    return node->template create_client<RegisterWorkcellService::ServiceType>(RegisterWorkcellService::service_name());
  }
};

class ControllerRobotTrajectoryAction {
public:
  using ActionType = control_msgs::action::FollowJointTrajectory;

  static inline std::string action_name() {
    const std::string name = "/joint_trajectory_controller/follow_joint_trajectory";
    return name;
  }

  template<typename NodePtrT>
  static rclcpp_action::Server<ControllerRobotTrajectoryAction::ActionType>::SharedPtr create_server(NodePtrT node, typename rclcpp_action::Server<ControllerRobotTrajectoryAction::ActionType>::GoalCallback handle_goal, typename rclcpp_action::Server<ControllerRobotTrajectoryAction::ActionType>::CancelCallback handle_cancel, typename rclcpp_action::Server<ControllerRobotTrajectoryAction::ActionType>::AcceptedCallback handle_accepted) {
    return rclcpp_action::create_server<ControllerRobotTrajectoryAction::ActionType>(node, ControllerRobotTrajectoryAction::action_name(), handle_goal, handle_cancel, handle_accepted);
  }

  template<typename NodePtrT>
  static rclcpp_action::Client<ControllerRobotTrajectoryAction::ActionType>::SharedPtr create_client(NodePtrT node) {
    return rclcpp_action::create_client<ControllerRobotTrajectoryAction::ActionType>(node, ControllerRobotTrajectoryAction::action_name());
  }
};

/**
 * Send a controller trajectory to a robot arm via topic
 */
class ControllerRobotTrajectoryTopic {
public:
  using MessageType = trajectory_msgs::msg::JointTrajectory;

  static inline std::string topic_name() {
    const std::string topic = "/joint_trajectory_position_controller/joint_trajectory";
    return topic;
  }

  static inline rclcpp::QoS qos(size_t history_depth = 10) {
    return rclcpp::QoS{history_depth};
  }

  template<typename NodePtrT>
  static rclcpp::Publisher<ControllerRobotTrajectoryTopic::MessageType>::SharedPtr create_publisher(NodePtrT node, size_t history_depth = 10) {
    return node->template create_publisher<ControllerRobotTrajectoryTopic::MessageType>(ControllerRobotTrajectoryTopic::topic_name(), ControllerRobotTrajectoryTopic::qos(history_depth));
  }

  template<typename NodePtrT, typename CallbackT>
  static rclcpp::Subscription<ControllerRobotTrajectoryTopic::MessageType>::SharedPtr create_subscription(NodePtrT node, CallbackT&& callback, size_t history_depth = 10) {
    return node->template create_subscription<ControllerRobotTrajectoryTopic::MessageType>(ControllerRobotTrajectoryTopic::topic_name(), ControllerRobotTrajectoryTopic::qos(history_depth), std::forward<CallbackT>(callback));
  }
};

class RegisterTransporterService {
public:
  using ServiceType = nexus_orchestrator_msgs::srv::RegisterTransporter;

  static inline std::string service_name() {
    const std::string name = "/register_transporter";
    return name;
  }

  template<typename NodePtrT, typename CallbackT>
  static rclcpp::Service<RegisterTransporterService::ServiceType>::SharedPtr create_service(NodePtrT node, CallbackT&& callback) {
    return node->template create_service<RegisterTransporterService::ServiceType>(RegisterTransporterService::service_name(), std::forward<CallbackT>(callback));
  }

  template<typename NodePtrT>
  static rclcpp::Client<RegisterTransporterService::ServiceType>::SharedPtr create_client(NodePtrT node) {
    return node->template create_client<RegisterTransporterService::ServiceType>(RegisterTransporterService::service_name());
  }
};

class ListTransporterService {
public:
  using ServiceType = nexus_orchestrator_msgs::srv::ListTransporters;

  static inline std::string service_name() {
    const std::string name = "/list_transporters";
    return name;
  }

  template<typename NodePtrT, typename CallbackT>
  static rclcpp::Service<ListTransporterService::ServiceType>::SharedPtr create_service(NodePtrT node, CallbackT&& callback) {
    return node->template create_service<ListTransporterService::ServiceType>(ListTransporterService::service_name(), std::forward<CallbackT>(callback));
  }

  template<typename NodePtrT>
  static rclcpp::Client<ListTransporterService::ServiceType>::SharedPtr create_client(NodePtrT node) {
    return node->template create_client<ListTransporterService::ServiceType>(ListTransporterService::service_name());
  }
};

class IsTransporterAvailableService {
public:
  using ServiceType = nexus_transporter_msgs::srv::IsTransporterAvailable;

  static inline std::string service_name(const std::string& transporter_id) {
    const std::string name = transporter_id + "/available";
    return name;
  }

  template<typename NodePtrT, typename CallbackT>
  static rclcpp::Service<IsTransporterAvailableService::ServiceType>::SharedPtr create_service(NodePtrT node, const std::string& transporter_id, CallbackT&& callback) {
    return node->template create_service<IsTransporterAvailableService::ServiceType>(IsTransporterAvailableService::service_name(transporter_id), std::forward<CallbackT>(callback));
  }

  template<typename NodePtrT>
  static rclcpp::Client<IsTransporterAvailableService::ServiceType>::SharedPtr create_client(NodePtrT node, const std::string& transporter_id) {
    return node->template create_client<IsTransporterAvailableService::ServiceType>(IsTransporterAvailableService::service_name(transporter_id));
  }
};

class TransportAction {
public:
  using ActionType = nexus_transporter_msgs::action::Transport;

  static inline std::string action_name(const std::string& transporter_id) {
    const std::string name = transporter_id + "/transport";
    return name;
  }

  template<typename NodePtrT>
  static rclcpp_action::Server<TransportAction::ActionType>::SharedPtr create_server(NodePtrT node, const std::string& transporter_id, typename rclcpp_action::Server<TransportAction::ActionType>::GoalCallback handle_goal, typename rclcpp_action::Server<TransportAction::ActionType>::CancelCallback handle_cancel, typename rclcpp_action::Server<TransportAction::ActionType>::AcceptedCallback handle_accepted) {
    return rclcpp_action::create_server<TransportAction::ActionType>(node, TransportAction::action_name(transporter_id), handle_goal, handle_cancel, handle_accepted);
  }

  template<typename NodePtrT>
  static rclcpp_action::Client<TransportAction::ActionType>::SharedPtr create_client(NodePtrT node, const std::string& transporter_id) {
    return rclcpp_action::create_client<TransportAction::ActionType>(node, TransportAction::action_name(transporter_id));
  }
};

class DetectorService {
public:
  using ServiceType = nexus_detector_msgs::srv::Detect;

  static inline std::string service_name(const std::string& detector_id) {
    const std::string name = detector_id + "/detect";
    return name;
  }

  template<typename NodePtrT, typename CallbackT>
  static rclcpp::Service<DetectorService::ServiceType>::SharedPtr create_service(NodePtrT node, const std::string& detector_id, CallbackT&& callback) {
    return node->template create_service<DetectorService::ServiceType>(DetectorService::service_name(detector_id), std::forward<CallbackT>(callback));
  }

  template<typename NodePtrT>
  static rclcpp::Client<DetectorService::ServiceType>::SharedPtr create_client(NodePtrT node, const std::string& detector_id) {
    return node->template create_client<DetectorService::ServiceType>(DetectorService::service_name(detector_id));
  }
};

class GripperCommandAction {
public:
  using ActionType = control_msgs::action::GripperCommand;

  static inline std::string action_name(const std::string& gripper_id) {
    const std::string name = gripper_id + "/command";
    return name;
  }

  template<typename NodePtrT>
  static rclcpp_action::Server<GripperCommandAction::ActionType>::SharedPtr create_server(NodePtrT node, const std::string& gripper_id, typename rclcpp_action::Server<GripperCommandAction::ActionType>::GoalCallback handle_goal, typename rclcpp_action::Server<GripperCommandAction::ActionType>::CancelCallback handle_cancel, typename rclcpp_action::Server<GripperCommandAction::ActionType>::AcceptedCallback handle_accepted) {
    return rclcpp_action::create_server<GripperCommandAction::ActionType>(node, GripperCommandAction::action_name(gripper_id), handle_goal, handle_cancel, handle_accepted);
  }

  template<typename NodePtrT>
  static rclcpp_action::Client<GripperCommandAction::ActionType>::SharedPtr create_client(NodePtrT node, const std::string& gripper_id) {
    return rclcpp_action::create_client<GripperCommandAction::ActionType>(node, GripperCommandAction::action_name(gripper_id));
  }
};

class GetMotionPlanService {
public:
  using ServiceType = nexus_motion_planner_msgs::srv::GetMotionPlan;

  static inline std::string service_name() {
    const std::string name = "/motion_planner_server/plan";
    return name;
  }

  template<typename NodePtrT, typename CallbackT>
  static rclcpp::Service<GetMotionPlanService::ServiceType>::SharedPtr create_service(NodePtrT node, CallbackT&& callback) {
    return node->template create_service<GetMotionPlanService::ServiceType>(GetMotionPlanService::service_name(), std::forward<CallbackT>(callback));
  }

  template<typename NodePtrT>
  static rclcpp::Client<GetMotionPlanService::ServiceType>::SharedPtr create_client(NodePtrT node) {
    return node->template create_client<GetMotionPlanService::ServiceType>(GetMotionPlanService::service_name());
  }
};

/**
 * Emergency stop alarm.
 * 
 * When this is triggered, all workcells will cancel their current action as soon as possible, all current work orders will fail and new work orders will not be accepted until it is cleared.
 * 
 */
class EmergencyStopTopic {
public:
  using MessageType = nexus_alarm_msgs::msg::EmergencyStop;

  static inline std::string topic_name() {
    const std::string topic = "/estop";
    return topic;
  }

  static inline rclcpp::QoS qos(size_t history_depth = 10) {
    return rclcpp::QoS{history_depth};
  }

  template<typename NodePtrT>
  static rclcpp::Publisher<EmergencyStopTopic::MessageType>::SharedPtr create_publisher(NodePtrT node, size_t history_depth = 10) {
    return node->template create_publisher<EmergencyStopTopic::MessageType>(EmergencyStopTopic::topic_name(), EmergencyStopTopic::qos(history_depth));
  }

  template<typename NodePtrT, typename CallbackT>
  static rclcpp::Subscription<EmergencyStopTopic::MessageType>::SharedPtr create_subscription(NodePtrT node, CallbackT&& callback, size_t history_depth = 10) {
    return node->template create_subscription<EmergencyStopTopic::MessageType>(EmergencyStopTopic::topic_name(), EmergencyStopTopic::qos(history_depth), std::forward<CallbackT>(callback));
  }
};

class PauseSystemService {
public:
  using ServiceType = nexus_orchestrator_msgs::srv::PauseSystem;

  static inline std::string service_name() {
    const std::string name = "/pause";
    return name;
  }

  template<typename NodePtrT, typename CallbackT>
  static rclcpp::Service<PauseSystemService::ServiceType>::SharedPtr create_service(NodePtrT node, CallbackT&& callback) {
    return node->template create_service<PauseSystemService::ServiceType>(PauseSystemService::service_name(), std::forward<CallbackT>(callback));
  }

  template<typename NodePtrT>
  static rclcpp::Client<PauseSystemService::ServiceType>::SharedPtr create_client(NodePtrT node) {
    return node->template create_client<PauseSystemService::ServiceType>(PauseSystemService::service_name());
  }
};

class PauseWorkcellService {
public:
  using ServiceType = nexus_orchestrator_msgs::srv::PauseWorkcell;

  static inline std::string service_name(const std::string& workcell_id) {
    const std::string name = "/" + workcell_id + "/pause";
    return name;
  }

  template<typename NodePtrT, typename CallbackT>
  static rclcpp::Service<PauseWorkcellService::ServiceType>::SharedPtr create_service(NodePtrT node, const std::string& workcell_id, CallbackT&& callback) {
    return node->template create_service<PauseWorkcellService::ServiceType>(PauseWorkcellService::service_name(workcell_id), std::forward<CallbackT>(callback));
  }

  template<typename NodePtrT>
  static rclcpp::Client<PauseWorkcellService::ServiceType>::SharedPtr create_client(NodePtrT node, const std::string& workcell_id) {
    return node->template create_client<PauseWorkcellService::ServiceType>(PauseWorkcellService::service_name(workcell_id));
  }
};

class SignalWorkcellService {
public:
  using ServiceType = nexus_orchestrator_msgs::srv::SignalWorkcell;

  static inline std::string service_name(const std::string& workcell_id) {
    const std::string name = "/" + workcell_id + "/signal";
    return name;
  }

  template<typename NodePtrT, typename CallbackT>
  static rclcpp::Service<SignalWorkcellService::ServiceType>::SharedPtr create_service(NodePtrT node, const std::string& workcell_id, CallbackT&& callback) {
    return node->template create_service<SignalWorkcellService::ServiceType>(SignalWorkcellService::service_name(workcell_id), std::forward<CallbackT>(callback));
  }

  template<typename NodePtrT>
  static rclcpp::Client<SignalWorkcellService::ServiceType>::SharedPtr create_client(NodePtrT node, const std::string& workcell_id) {
    return node->template create_client<SignalWorkcellService::ServiceType>(SignalWorkcellService::service_name(workcell_id));
  }
};

class DispenserService {
public:
  using ServiceType = nexus_dispenser_msgs::srv::DispenseItem;

  static inline std::string service_name(const std::string& dispenser_id) {
    const std::string name = dispenser_id + "/dispense";
    return name;
  }

  template<typename NodePtrT, typename CallbackT>
  static rclcpp::Service<DispenserService::ServiceType>::SharedPtr create_service(NodePtrT node, const std::string& dispenser_id, CallbackT&& callback) {
    return node->template create_service<DispenserService::ServiceType>(DispenserService::service_name(dispenser_id), std::forward<CallbackT>(callback));
  }

  template<typename NodePtrT>
  static rclcpp::Client<DispenserService::ServiceType>::SharedPtr create_client(NodePtrT node, const std::string& dispenser_id) {
    return node->template create_client<DispenserService::ServiceType>(DispenserService::service_name(dispenser_id));
  }
};

class ExtrinsicCalibrationService {
public:
  using ServiceType = nexus_calibration_msgs::srv::CalibrateExtrinsics;

  static inline std::string service_name(const std::string& workcell_id) {
    const std::string name = "/" + workcell_id + "/calibrate_extrinsics";
    return name;
  }

  template<typename NodePtrT, typename CallbackT>
  static rclcpp::Service<ExtrinsicCalibrationService::ServiceType>::SharedPtr create_service(NodePtrT node, const std::string& workcell_id, CallbackT&& callback) {
    return node->template create_service<ExtrinsicCalibrationService::ServiceType>(ExtrinsicCalibrationService::service_name(workcell_id), std::forward<CallbackT>(callback));
  }

  template<typename NodePtrT>
  static rclcpp::Client<ExtrinsicCalibrationService::ServiceType>::SharedPtr create_client(NodePtrT node, const std::string& workcell_id) {
    return node->template create_client<ExtrinsicCalibrationService::ServiceType>(ExtrinsicCalibrationService::service_name(workcell_id));
  }
};

}
